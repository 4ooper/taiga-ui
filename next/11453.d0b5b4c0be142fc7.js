(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[11453],{11453:e=>{e.exports="import type {OnInit} from '@angular/core';\nimport {ChangeDetectionStrategy, Component, inject, ViewChild} from '@angular/core';\nimport {FormControl, FormGroup, Validators} from '@angular/forms';\nimport type {TuiCard, TuiInputCardGroupedComponent} from '@taiga-ui/addon-commerce';\nimport {tuiCardNumberValidator, tuiDefaultCardValidator} from '@taiga-ui/addon-commerce';\nimport type {TuiValuesOf} from '@taiga-ui/cdk';\nimport {TUI_IS_IOS, TuiDestroyService} from '@taiga-ui/cdk';\nimport type {TuiDialogContext} from '@taiga-ui/core';\nimport {POLYMORPHEUS_CONTEXT} from '@tinkoff/ng-polymorpheus';\nimport {BehaviorSubject, map, switchMap, takeUntil} from 'rxjs';\n\nimport type {AccountCard, DataForPayCardModal, FetchedCards} from '../helpers/models';\nimport {PaymentMode} from '../helpers/models';\nimport {PayService} from '../helpers/pay.service';\nimport {inputCardGroupedCVCValidator} from '../helpers/validator';\n\n@Component({\n    selector: 'pay-modal',\n    templateUrl: './pay-modal.component.html',\n    styleUrls: ['./pay-modal.component.less'],\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [TuiDestroyService],\n})\nexport class PayModalComponent implements OnInit {\n    @ViewChild('cardGroupedInput')\n    private readonly cardGroupedInput?: TuiInputCardGroupedComponent;\n\n    private readonly payService = inject(PayService);\n    private readonly destroy$ = inject(TuiDestroyService, {self: true});\n\n    protected readonly form = new FormGroup({\n        card: new FormControl<TuiCard | null>(null, [\n            Validators.required,\n            inputCardGroupedCVCValidator(),\n        ]),\n        saveCard: new FormControl(true),\n    });\n\n    protected readonly context =\n        inject<TuiDialogContext<void, DataForPayCardModal>>(POLYMORPHEUS_CONTEXT);\n\n    protected readonly iOS = inject(TUI_IS_IOS);\n\n    protected cards: AccountCard[] = [];\n    protected paymentMode: TuiValuesOf<typeof PaymentMode> = PaymentMode.ByNewCard;\n    protected loading$ = new BehaviorSubject(false);\n    protected payProcessing$ = new BehaviorSubject(false);\n    protected amount: number = this.context?.data?.amount ?? 0;\n    protected readonly PAYMENT_MODE = PaymentMode;\n\n    public ngOnInit(): void {\n        this.fetchCardsAndSetPrimaryCard();\n    }\n\n    protected payBySelectedCard(card: AccountCard): void {\n        this.form.patchValue({\n            card: {card: this.maskedNumber(card), expire: '**/**', cvc: ''},\n        });\n\n        this.form.controls.card.removeValidators(tuiCardNumberValidator);\n        this.paymentMode = PaymentMode.BySavedCard;\n        this.cardGroupedInput?.focusCVC();\n    }\n\n    protected payByNewCard(): void {\n        this.form.patchValue({card: null});\n        this.form.controls.card.addValidators(tuiCardNumberValidator);\n        this.paymentMode = PaymentMode.ByNewCard;\n        this.cardGroupedInput?.focusCard();\n    }\n\n    protected pay(): void {\n        if (!this.form.controls.card.valid) {\n            return;\n        }\n\n        this.payProcessing$.next(true);\n        this.payService\n            .pay()\n            .pipe(takeUntil(this.destroy$))\n            .subscribe(\n                () => {\n                    this.payProcessing$.next(false);\n                    this.context.$implicit.complete();\n                },\n                () => this.payProcessing$.next(false),\n            );\n    }\n\n    protected cardValidator(card: string): boolean {\n        return tuiDefaultCardValidator(card) && card.length === 16;\n    }\n\n    private maskedNumber(savedCard: AccountCard): string {\n        return `${savedCard.firstSix.toString().slice(0, -2)}***${savedCard.lastFour}`;\n    }\n\n    private fetchCardsAndSetPrimaryCard(): void {\n        this.loading$.next(true);\n        this.payService\n            .preparePayment(this.context.data.amount)\n            .pipe(\n                switchMap(amount =>\n                    this.payService\n                        .getPrimaryCard()\n                        .pipe(map(data => [amount, data] as [number, FetchedCards])),\n                ),\n                takeUntil(this.destroy$),\n            )\n            .subscribe({\n                next: ([, data]: [number, FetchedCards]) => {\n                    this.cards = data.cards;\n\n                    if (data.primary) {\n                        this.payBySelectedCard(data.primary);\n                    } else {\n                        this.payByNewCard();\n                    }\n                },\n                complete: () => this.loading$.next(false),\n            });\n    }\n}\n"}}]);